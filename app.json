[{"name": "app.py", "content": "import matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom shiny.express import input, output, render, ui\n\n# Thelen muscle model with full calculations\ndef thelen_muscle(onoff, freq, excursion, L0, F0, Vx, af, tau_a, tau_d):\n    try:\n        onset = onoff[0] / 100\n        offset = onoff[1] / 100\n        excursion = excursion / 1000  # Convert mm to meters\n        tau_a = tau_a / 1000  # Convert to seconds\n        tau_d = tau_d / 1000  # Convert to seconds\n\n        act_pct = 1\n        onset_time = onset / freq\n        offset_time = offset / freq\n        dt = 0.001 / freq  # Time step\n        V0 = Vx * L0\n        penn0 = 0.087\n        k_shape = 0.5\n        w = L0 * np.sin(penn0)\n\n        # Time and cycle percentage\n        t = np.arange(0, 1.25 / freq, dt)\n        cycle_pct = t * freq\n\n        # Position\n        position = excursion * np.sin(2 * np.pi * freq * t)\n        position_mm = position * 1000\n\n        # Excitation and Activation Dynamics\n        excitation = np.where((t >= onset_time) & (t <= offset_time), 1 * act_pct, 0)\n        da_dt = np.zeros(len(t))\n        activation = np.zeros(len(t))\n\n        for i in range(1, len(t)):\n            if excitation[i - 1] >= activation[i - 1]:\n                da_dt[i] = (excitation[i - 1] - activation[i - 1]) / tau_a\n            else:\n                da_dt[i] = (excitation[i - 1] - activation[i - 1]) / tau_d\n            activation[i] = activation[i - 1] + da_dt[i] * dt\n\n        # Pennation and muscle length\n        penn = np.arcsin(w / (position + L0))\n        muscle_length = position / np.cos(penn0) + L0\n        muscle_length_norm = muscle_length / L0\n\n        # Velocity\n        v = (-2 * np.pi * freq * excursion * np.cos(2 * np.pi * freq * t)) / np.cos(penn)\n        v_norm = v / (V0 * ((Vx / 2) + (Vx / 2) * activation) / Vx)\n\n        # Force-Length relationship\n        fl_norm = np.exp(-((muscle_length_norm - 1) ** 2) / k_shape)\n\n        # Force-Velocity relationship\n        fv_norm = np.where(v > (V0 * ((Vx / 2) + (Vx / 2))), 0,\n                           np.where(v_norm > 0, (1 - v_norm) / (1 + v_norm / af),\n                                    (1.8 - (0.8 * (1 + v / V0)) / (1 - 7.56 * 0.21 * v / V0))))\n\n        # Contractile element force\n        force_ce = activation * F0 * fl_norm * fv_norm\n\n        # Total force\n        force_total = force_ce\n\n        # Work and Power calculations\n        work = force_total * v * dt\n        power = force_total * v\n        work_actual = np.sum(work)\n        work_positive = np.sum(work[work > 0])\n        work_negative = np.sum(work[work < 0])\n        power_actual = np.mean(power[(t >= onset_time) & (t <= onset_time + 1)])\n\n        # Data to return\n        sim_data = pd.DataFrame({\n            't': t,\n            'cycle_pct': cycle_pct,\n            'position': position,\n            'position_mm': position_mm,\n            'velocity': v,\n            'force_total': force_total,\n            'work': work,\n            'power': power,\n            'excitation': excitation,\n            'activation': activation\n        })\n\n        return {\n            'sim_data': sim_data,\n            'work_actual': work_actual,\n            'work_positive': work_positive,\n            'work_negative': work_negative,\n            'power_actual': power_actual\n        }\n    except Exception as e:\n        print(f\"Error in thelen_muscle: {e}\")\n        return None\n\n# Optimization function for the Thelen model\ndef thelen_muscle_opt(freq, excursion, L0, F0, Vx, af, tau_a, tau_d):\n    onset_values = np.arange(20, 26, 1)\n    offset_values = np.arange(26, 76, 1)\n\n    best_onset = None\n    best_offset = None\n    max_power = -np.inf\n\n    for onset in onset_values:\n        for offset in offset_values:\n            sim_results = thelen_muscle([onset, offset], freq, excursion, L0, F0, Vx, af, tau_a, tau_d)\n            if sim_results is None:\n                continue\n\n            current_power = sim_results['power_actual']\n\n            if current_power > max_power:\n                best_onset = onset\n                best_offset = offset\n                max_power = current_power\n\n    if best_onset is not None and best_offset is not None:\n        optimized_results = thelen_muscle([best_onset, best_offset], freq, excursion, L0, F0, Vx, af, tau_a, tau_d)\n        return optimized_results, best_onset, best_offset, max_power\n    return None, None, None, None\n\n# Define the run_simulation function\ndef run_simulation():\n    muscle_params = {\n        \"onoff\": [input.onset(), input.offset()],\n        \"freq\": input.cycle_freq(),\n        \"excursion\": input.excursion(),\n        \"L0\": input.length_optimal(),\n        \"F0\": input.max_isometric_force(),\n        \"Vx\": input.max_velocity(),\n        \"af\": input.force_velocity_curvature(),\n        \"tau_a\": input.activation_time(),\n        \"tau_d\": input.deactivation_time(),\n    }\n    if input.optimize():\n        sim_results, _, _, _ = thelen_muscle_opt(\n            input.cycle_freq(), input.excursion(), input.length_optimal(),\n            input.max_isometric_force(), input.max_velocity(),\n            input.force_velocity_curvature(), input.activation_time(),\n            input.deactivation_time()\n        )\n    else:\n        sim_results = thelen_muscle(**muscle_params)\n\n    return sim_results\n\n# Define the UI layout\nwith ui.sidebar():\n            ui.input_slider(\"onset\", \"Onset (% of cycle)\", min=20, max=25, value=22),\n            ui.input_slider(\"offset\", \"Offset (% of cycle)\", min=26, max=100, value=66),\n            ui.input_slider(\"excursion\", \"Excursion amplitude (mm)\", min=1, max=50, value=20),\n            ui.input_slider(\"cycle_freq\", \"Cycle frequency (Hz)\", min=0.5, max=4.5, value=2.0),\n            ui.input_numeric(\"length_optimal\", \"Length optimal (m)\", value=0.084),\n            ui.input_numeric(\"max_isometric_force\", \"Max isometric force (N)\", value=1871),\n            ui.input_numeric(\"max_velocity\", \"Max velocity (fiber lengths/s)\", value=10),\n            ui.input_numeric(\"force_velocity_curvature\", \"Force-velocity curvature\", value=0.30),\n            ui.input_numeric(\"activation_time\", \"Activation time (ms)\", value=10),\n            ui.input_numeric(\"deactivation_time\", \"Deactivation time (ms)\", value=40),\n            ui.input_action_button(\"run_sim\", \"Run Simulation\"),\n            ui.input_checkbox(\"optimize\", \"Optimize Onset/Offset\", value=False)\n\n\nwith ui.card():\n    with ui.navset_bar(title=\"Virtual Muscle Lab\"):\n        with ui.nav_panel(title=\"Graphs\"):\n            \n# Define Server logic and plotting\n   \n            @render.plot\n            def force_cycle():\n                sim_results = run_simulation()\n                if sim_results is None:\n                    print(\"Simulation failed: sim_results is None\")\n                    return\n                fig, ax = plt.subplots()\n                sim_results = run_simulation()\n                ax.plot(sim_results['sim_data']['cycle_pct'], sim_results['sim_data']['force_total'])\n                ax.set_title(\"Force vs. % of Cycle\")\n                return fig\n\n\n    @render.plot\n    def velocity_cycle():\n        sim_results = run_simulation()\n        if sim_results is None:\n            print(\"Simulation failed: sim_results is None\")\n            return\n        fig, ax = plt.subplots()\n        ax.plot(sim_results['sim_data']['cycle_pct'], sim_results['sim_data']['velocity'])\n        ax.set_title(\"Velocity vs. % of Cycle\")\n        return fig\n\n    \n    @render.plot\n    def position_cycle():\n        sim_results = run_simulation()\n        if sim_results is None:\n            print(\"Simulation failed: sim_results is None\")\n            return\n        fig, ax = plt.subplots()\n        ax.plot(sim_results['sim_data']['cycle_pct'], sim_results['sim_data']['position'])\n        ax.set_title(\"Position vs. % of Cycle\")\n        return fig\n\n   \n    @render.plot\n    def power_cycle():\n        sim_results = run_simulation()\n        if sim_results is None:\n            print(\"Simulation failed: sim_results is None\")\n            return\n        fig, ax = plt.subplots()\n        ax.plot(sim_results['sim_data']['cycle_pct'], sim_results['sim_data']['power'])\n        ax.set_title(\"Power vs. % of Cycle\")\n        return fig\n\n   \n    @render.table\n    def results():\n        sim_results = run_simulation()\n        if sim_results is None:\n            print(\"Simulation failed: sim_results is None\")\n            return pd.DataFrame()\n        return pd.DataFrame({\n            \"Total Work\": [sim_results['work_actual']],\n            \"Positive Work\": [sim_results['work_positive']],\n            \"Negative Work\": [sim_results['work_negative']],\n            \"Power\": [sim_results['power_actual']]\n        })\n\n# Create the Shiny app instance\n", "type": "text"}]